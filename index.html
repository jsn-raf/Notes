<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Quick Notes</title>

  <link rel="manifest" href="/Notes/manifest.webmanifest">
  <meta name="theme-color" content="#f5f6f7">
  <meta name="mobile-web-app-capable" content="yes">

  <style>
    body{
      font-family:'Segoe UI', Roboto, sans-serif;
      margin:0;
      background:#fff;
      color:#202124;
      overflow:hidden;
      -webkit-tap-highlight-color:transparent;
    }

    .toolbar{
      background:#f5f6f7;
      padding:15px;
      display:flex;
      align-items:center;
      border-bottom:1px solid #e3e5e7;
      height:50px;
      position:relative;
      touch-action:manipulation;
      user-select:none;
      -webkit-user-select:none;
      -webkit-touch-callout:none;
    }

    .toolbar *{
      user-select:none !important;
      -webkit-user-select:none !important;
      -webkit-touch-callout:none !important;
    }

    .back-arrow{
      font-size:20px;
      color:#5f6368;
      cursor:pointer;
      padding:8px 10px;
      margin:-8px -10px;
      z-index:3;
      position:relative;
    }

    .title{
      font-weight:500;
      margin-left:20px;
      pointer-events:none;
    }

    .calc-trigger{
      position:absolute;
      right:6px;
      top:50%;
      transform:translateY(-50%);
      width:44px;
      height:44px;
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
    }

    .dots{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:3px;
    }

    .vdot{
      width:4px;
      height:4px;
      border-radius:50%;
      background:#5f6368;
      opacity:0.65;
    }

    .calc-trigger.armed-top .vdot.top{ background:#202124; opacity:1; }
    .calc-trigger.armed-mid .vdot.mid{ background:#202124; opacity:1; }
    .calc-trigger.armed-bottom .vdot.bottom{ background:#202124; opacity:1; }

    .peek-arrow{
      position:absolute;
      left:24px;
      top:50%;
      transform:translateY(-50%);
      display:none;
      pointer-events:none;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size:12px;
      font-weight:700;
      line-height:1;
      letter-spacing:0.02em;
      color:#202124;
      text-align:center;
      z-index:2;
    }
    .peek-arrow .card{ display:block; margin-bottom:9px; }
    .peek-arrow .shift{ display:block; margin-top:9px; }

    .note-area{ padding:20px; }

    .note-body{
      font-size:18px;
      border:none;
      outline:none;
      width:100%;
      min-height:calc(100vh - 120px);
      resize:none;
      line-height:1.6;
      background:transparent;
      color:#202124;
      caret-color:#202124;
      -webkit-overflow-scrolling:touch;
    }

    body.modal-open .toolbar,
    body.modal-open .note-area{
      pointer-events:none;
    }

    .about-overlay{
      position:fixed;
      inset:0;
      background:rgba(0,0,0,0.06);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:50;
    }

    .about-card{
      width:calc(100% - 72px);
      max-width:420px;
      background:#fff;
      border-radius:10px;
      padding:16px 16px 14px;
      box-shadow:0 6px 18px rgba(0,0,0,0.10);
      cursor:pointer;
      text-align:left;
    }

    .about-card, .about-card *{
      user-select:none !important;
      -webkit-user-select:none !important;
      -webkit-touch-callout:none !important;
      -webkit-tap-highlight-color:transparent !important;
      -webkit-user-drag:none !important;
    }

    .about-title{
      font-size:14.5px;
      font-weight:500;
      margin:0 0 10px 0;
      pointer-events:none;
    }

    .about-body{
      font-size:13.5px;
      line-height:1.45;
      pointer-events:none;
    }

    .about-body p{ margin:0 0 10px 0; }

    .about-footer{
      margin-top:10px;
      font-size:12px;
      line-height:1.35;
      color:#6b7077;
      pointer-events:none;
    }
  </style>
</head>

<body>

  <!-- Toolbar -->
  <div class="toolbar" id="toolbarBtn">
    <span class="back-arrow" id="resetBtn">←</span>

    <div class="peek-arrow" id="peekArrow">
      <span class="card" id="peekCard"></span>
      <span class="shift" id="peekShift"></span>
    </div>

    <span class="title">Quick Notes</span>

    <div class="calc-trigger" id="aboutBtn" aria-label="More options">
      <div class="dots">
        <span class="vdot top"></span>
        <span class="vdot mid"></span>
        <span class="vdot bottom"></span>
      </div>
    </div>
  </div>

  <!-- Main note -->
  <div class="note-area">
    <textarea id="noteContent" class="note-body" placeholder="Start typing…"></textarea>
  </div>

  <!-- About overlay -->
  <div class="about-overlay" id="aboutOverlay" aria-hidden="true">
    <div class="about-card" id="aboutCard">
      <div class="about-title">Quick Notes</div>
      <div class="about-body">
        <p>
          A lightweight note-taking utility for quick capture. Clean layout focused on speed and clarity.
          All content is stored locally on your device. Accessible without setup or accounts.
          Nothing is shared or synced externally.
        </p>
        <div class="about-footer">
          Build 1.3-g4l4h4d · Jan 2026<br>
          © Jason Parry
        </div>
      </div>
    </div>
  </div>

  <script>
    "use strict";

    /* ===============================
       DOM references
    =============================== */
    const toolbarBtn   = document.getElementById("toolbarBtn");
    const resetBtn     = document.getElementById("resetBtn");
    const aboutBtn     = document.getElementById("aboutBtn");
    const aboutOverlay = document.getElementById("aboutOverlay");
    const aboutCard    = document.getElementById("aboutCard");

    const noteContent  = document.getElementById("noteContent");
    const peekArrow    = document.getElementById("peekArrow");
    const peekCard     = document.getElementById("peekCard");
    const peekShift    = document.getElementById("peekShift");

    /* ===============================
       Constants
    =============================== */
    const HOLD_MS = 650;
    const MOVE_TOL = 10;

    // Mnemonica (as hard-coded in your build)
    const stack = [
      "4C","2H","7D","3C","4H","6D","AS","5H","9S","2S","QH","3D",
      "QC","8H","6S","5S","9H","KC","2D","JH","3S","8S","6H","10C",
      "5D","KD","2C","3H","8D","5C","KS","JD","8C","10S","KH","JC",
      "7S","10H","AD","4S","7H","4D","AC","9C","JS","QD","7C","QS",
      "10D","6C","AH","9D"
    ];

    /* ===============================
       State
    =============================== */
    let lastOutCard = null;
    let lastOutShift = null;

    let lastComputedSnapshot = null;
    let isDirty = true;

    let holdTimer = null;
    let peekShownThisGesture = false;
    let startX = 0, startY = 0;

    let startedOnReset = false;
    let startedOnAbout = false;

    /* ===============================
       Parsing helpers
       - Compact forms accept single-letter suits (AS, 10H, Q♣).
       - Wordy forms require suit words or suit symbols (prevents "sd" false positives).
    =============================== */
    const suitWordMap = {
      SPADES:"S", SPADE:"S",
      HEARTS:"H", HEART:"H",
      DIAMONDS:"D", DIAMOND:"D",
      CLUBS:"C", CLUB:"C"
    };

    const rankWordMap = {
      ACE:"A", KING:"K", QUEEN:"Q", JACK:"J",
      TEN:"10", NINE:"9", EIGHT:"8", SEVEN:"7", SIX:"6",
      FIVE:"5", FOUR:"4", THREE:"3", TWO:"2"
    };

    const suitSymbolMap = { "♠":"S","♥":"H","♦":"D","♣":"C" };

    function findCardWithSpan(text) {
      if (!text) return null;
      const raw = String(text);

      // 1) Compact (with optional whitespace): "AS", "A S", "10H", "7♦"
      const compact = /(10|[2-9AJQK])\s*([CDHS♠♥♦♣])/ig;
      let m;
      while ((m = compact.exec(raw)) !== null) {
        const r = String(m[1]).toUpperCase();
        const suitRaw = String(m[2]);
        const s = suitSymbolMap[suitRaw] || suitRaw.toUpperCase();
        const code = r + s;
        if (/^(10|[2-9AJQK])[CDHS]$/.test(code)) {
          return { code, start: m.index, end: m.index + m[0].length };
        }
      }

      // 2) Wordy token pairing (with real spans from token matches)
      const tokenRe = /[A-Za-z0-9♠♥♦♣]+/g;
      let tok;
      let rank = null, suit = null;
      let rankSpan = null, suitSpan = null;

      while ((tok = tokenRe.exec(raw)) !== null) {
        const token = tok[0];
        const upper = token.toUpperCase();
        const s = tok.index;
        const e = s + token.length;

        if (upper === "OF" || upper === "THE") continue;

        if (!rank) {
          if (rankWordMap[upper]) {
            rank = rankWordMap[upper];
            rankSpan = { start: s, end: e };
          } else if (/^(10|[2-9])$/.test(upper)) {
            rank = upper;
            rankSpan = { start: s, end: e };
          } else if (/^[AJQK]$/.test(upper)) {
            rank = upper;
            rankSpan = { start: s, end: e };
          }
        }

        if (!suit) {
          if (suitWordMap[upper]) {
            suit = suitWordMap[upper];
            suitSpan = { start: s, end: e };
          } else if (suitSymbolMap[token]) {
            suit = suitSymbolMap[token];
            suitSpan = { start: s, end: e };
          }
        }

        if (rank && suit) break;
      }

      if (!rank || !suit) return null;

      const code = rank + suit;
      if (!/^(10|[2-9AJQK])[CDHS]$/.test(code)) return null;

      const start = Math.min(rankSpan.start, suitSpan.start);
      const end   = Math.max(rankSpan.end, suitSpan.end);

      return { code, start, end };
    }

    function normaliseCard(text) {
      const f = findCardWithSpan(text);
      return f ? f.code : null;
    }

    function normaliseNumberTextKeepLength(s) {
      return String(s ?? "")
        .replace(/\u00A0/g, " ")
        .replace(/[\u2010-\u2014]/g, "-");
    }

    const ones = {
      ONE:1,TWO:2,THREE:3,FOUR:4,FIVE:5,SIX:6,SEVEN:7,EIGHT:8,NINE:9,
      TEN:10,ELEVEN:11,TWELVE:12,THIRTEEN:13,FOURTEEN:14,FIFTEEN:15,
      SIXTEEN:16,SEVENTEEN:17,EIGHTEEN:18,NINETEEN:19
    };
    const tens = { TWENTY:20, THIRTY:30, FORTY:40, FIFTY:50 };

    function findPositionSpan(line) {
      const s = normaliseNumberTextKeepLength(String(line ?? ""));
      if (!s.trim()) return null;

      // Digits
      const d = /\d+/.exec(s);
      if (d) {
        const v = parseInt(d[0], 10);
        if (Number.isFinite(v) && v >= 1 && v <= 52) {
          return { value: v, start: d.index, end: d.index + d[0].length };
        }
        return null;
      }

      // Words (supports "twenty one" / "twenty-one")
      const re = /\b(one|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen|twenty|thirty|forty|fifty)(?:[-\s]+(one|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen))?\b/ig;
      let best = null;
      let m;
      while ((m = re.exec(s)) !== null) {
        const a = String(m[1]).toUpperCase();
        const b = m[2] ? String(m[2]).toUpperCase() : null;

        let v = NaN;
        if (ones[a] != null) v = ones[a];
        else if (tens[a] != null && b && ones[b] != null) v = tens[a] + ones[b];
        else if (tens[a] != null && !b) v = tens[a];

        if (Number.isFinite(v) && v >= 1 && v <= 52) {
          const cand = { value: v, start: m.index, end: m.index + m[0].length };
          if (!best || (cand.end - cand.start) > (best.end - best.start)) best = cand;
        }
      }
      return best;
    }

    function removeSpanPolished(orig, start, end) {
      let before = orig.slice(0, start).replace(/\b(of|the)\b[\s\-]*$/i, "");
      let after  = orig.slice(end).replace(/^[\s\-]*\b(of|the)\b/i, "");
      return (before + after).replace(/\s{2,}/g, " ").replace(/[ \t]+$/g, "").trimEnd();
    }

    /* ===============================
       Deck helpers
    =============================== */
    function buildDeckNow(bottomCard) {
      if (!bottomCard) return stack.slice();
      const bi = stack.indexOf(bottomCard);
      if (bi < 0) return null;
      // Rotate so the supplied bottom card remains bottom (cycle preserved)
      return stack.slice(bi + 1).concat(stack.slice(0, bi + 1));
    }

    /* ===============================
       UI helpers
    =============================== */
    function clearArmed() {
      aboutBtn.classList.remove("armed-top","armed-mid","armed-bottom");
    }
    function setArmedMode(mode) {
      clearArmed();
      if (mode === "mid") aboutBtn.classList.add("armed-mid");
      else if (mode === "bottom") aboutBtn.classList.add("armed-bottom");
      else aboutBtn.classList.add("armed-top");
    }

    function showPeek() {
      if (!lastOutCard) return;
      peekCard.textContent = lastOutCard;
      peekShift.textContent = lastOutShift;
      peekArrow.style.display = "block";
    }
    function hidePeek() {
      peekArrow.style.display = "none";
      peekCard.textContent = "";
      peekShift.textContent = "";
    }

    function openAbout() {
      hidePeek();
      noteContent.blur();
      document.body.classList.add("modal-open");
      aboutOverlay.style.display = "flex";
    }
    function closeAbout() {
      aboutOverlay.style.display = "none";
      document.body.classList.remove("modal-open");
    }
    function aboutIsOpen() {
      return aboutOverlay.style.display === "flex";
    }

    /* ===============================
       Core compute
       Inputs:
       - Line 1: named card
       - Line 2: position (1..52) optionally followed by bottom card (inline cut)
       - Line 3: bottom card (preferred if present)
       Deletions:
       - If line 3 used: delete line 3 (keep lines 1–2 as typed)
       - If inline used: delete only the card substring on line 2 (preserve number formatting)
    =============================== */
    function compute() {
      if (!isDirty && lastComputedSnapshot === noteContent.value) return;

      const raw = noteContent.value.split("\n");
      const line1 = raw[0] ?? "";
      const line2 = raw[1] ?? "";
      const line3 = raw[2] ?? "";

      if (!line1.trim() || !line2.trim()) return;

      const namedCard = normaliseCard(line1);
      const posSpan = findPositionSpan(line2);
      if (!namedCard || !posSpan) return;

      let bottomCard = null;
      let mode = "top";
      let inlineSpan = null;

      // Prefer line 3 bottom card
      if (line3.trim()) {
        const b3 = normaliseCard(line3);
        if (!b3) return; // invalid third line: do nothing
        bottomCard = b3;
        mode = "bottom";
      } else {
        // Inline bottom card: only scan after the number span
        const remainder = line2.slice(posSpan.end);
        const found = findCardWithSpan(remainder);
        if (found) {
          bottomCard = found.code;
          mode = "mid";
          inlineSpan = { s: posSpan.end + found.start, e: posSpan.end + found.end };
        }
      }

      const deckNow = buildDeckNow(bottomCard);
      if (!deckNow) return;

      const currentPos = deckNow.indexOf(namedCard) + 1;
      if (currentPos <= 0) return;

      const diff = currentPos - posSpan.value;

      if (diff === 0) {
        lastOutCard = "00";
        lastOutShift = "0";
      } else {
        let shift = diff % 52;
        if (shift < 0) shift += 52;
        lastOutCard = deckNow[shift - 1];
        lastOutShift = String(shift);
      }

      // Apply deletions (but keep the user's number formatting unchanged)
      if (mode === "bottom") {
        noteContent.value = line1 + "\n" + line2;
      } else if (mode === "mid" && inlineSpan) {
        noteContent.value = line1 + "\n" + removeSpanPolished(line2, inlineSpan.s, inlineSpan.e);
      }

      setArmedMode(mode);
      lastComputedSnapshot = noteContent.value;
      isDirty = false;
    }

    /* ===============================
       Event wiring
    =============================== */
    toolbarBtn.addEventListener("contextmenu", e => e.preventDefault());
    aboutOverlay.addEventListener("contextmenu", e => e.preventDefault());
    aboutCard.addEventListener("contextmenu", e => e.preventDefault());

    noteContent.addEventListener("input", () => {
      isDirty = true;
      lastOutCard = null;
      lastOutShift = null;
      clearArmed();
      hidePeek();
    });

    // Dots: About only (never compute/peek)
    ["pointerdown","pointerup","click"].forEach(evt => {
      aboutBtn.addEventListener(evt, (e) => {
        e.preventDefault();
        e.stopPropagation();
      });
    });
    aboutBtn.addEventListener("click", () => {
      aboutIsOpen() ? closeAbout() : openAbout();
    });

    // About closes on any tap (overlay or card)
    aboutOverlay.addEventListener("click", (e) => { e.preventDefault(); closeAbout(); });
    aboutCard.addEventListener("click", (e) => { e.preventDefault(); e.stopPropagation(); closeAbout(); });

    // Toolbar: tap compute, hold peek
    toolbarBtn.addEventListener("pointerdown", (e) => {
      if (aboutIsOpen()) return;

      startedOnReset = !!e.target.closest("#resetBtn");
      startedOnAbout = !!e.target.closest("#aboutBtn");
      if (startedOnReset || startedOnAbout) return;

      noteContent.blur();

      peekShownThisGesture = false;
      startX = e.clientX;
      startY = e.clientY;

      clearTimeout(holdTimer);
      holdTimer = setTimeout(() => {
        peekShownThisGesture = true;
        showPeek();
      }, HOLD_MS);
    });

    toolbarBtn.addEventListener("pointermove", (e) => {
      if (!holdTimer) return;
      if (Math.abs(e.clientX - startX) > MOVE_TOL || Math.abs(e.clientY - startY) > MOVE_TOL) {
        clearTimeout(holdTimer);
        holdTimer = null;
        hidePeek();
      }
    });

    toolbarBtn.addEventListener("pointerup", () => {
      if (aboutIsOpen()) return;

      clearTimeout(holdTimer);
      holdTimer = null;

      if (startedOnReset) { startedOnReset = false; return; }
      if (startedOnAbout) { startedOnAbout = false; return; }

      if (peekShownThisGesture) {
        hidePeek();
        clearArmed();
      } else {
        hidePeek();
        setTimeout(compute, 50);
      }
    });

    toolbarBtn.addEventListener("pointercancel", () => {
      clearTimeout(holdTimer);
      holdTimer = null;
      hidePeek();
    });

    // Reset arrow
    resetBtn.addEventListener("click", () => {
      if (aboutIsOpen()) return;

      clearTimeout(holdTimer);
      holdTimer = null;

      noteContent.blur();
      noteContent.value = "";

      lastOutCard = null;
      lastOutShift = null;
      clearArmed();
      hidePeek();

      lastComputedSnapshot = null;
      isDirty = true;
    });

    // Service worker
    if ("serviceWorker" in navigator) {
      navigator.serviceWorker.register("/Notes/sw.js").catch(() => {});
    }
  </script>
</body>
</html>
